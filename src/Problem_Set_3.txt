2.
    a. The strings the CFG recognizes a balanced set of zeroes and ones.
    b. "0110"
    c.

4.
    a. The memory value of i is 5. The memory value of j is 8. i's value is changed
       to 2 + 5 * 8 (42). The final value of i is 42. The final value of j is 8.

    b. The memory value of i is 3. The memory value of j is 8. If the value of
       i times 3 is greater than the value j, then i is changed to 3 times j, otherwise
       j is set to the value of 3 times i. The final memory value of i is 24 ( 3 times 8).
       The final value of j is 8.

    c. The memory value of i is 1. The memory value of j is 10. While the value
       of 3 times the value of i is less than or equal to the value of j, set the
       value of i to 3 times the current value of i. The final memory value of
       i is 9. The final memory value of j is 10.

9. A formula for the evaluation of k twices of successor 0 is:

   sigma 2^k from k=1 to infinity.

10. FSharp is left-associative, so first FSharp determines that a function that
    takes f as a parameter of type 'a is to be expected. Next, Fsharp determines that the
    first call to function f is a sub-call to f as well. Finally, FSharp determines
    that the inner call to function f is of type float, meaning input
    and output should be of type float since no other hints
    are specified. Finally, FSharp takes typings to mean that the lambda
    function is of type f:(float -> float) -> float.

14. Using the example code provided in 'problem_14.c', the type derivation is
    as follows:
        int *x is a pointer to an address space that is the size of an int.
        int a[15] is a sized array of 15 integers.

        *x = 7 sets the value of what x points to (an integer) to 7.
        a[*x] = *x + 4 sets the value of array a at index 7 to 7 plus 4 (11).

    Using my example code, the assignments are confirmed to work correctly.

15.

============================= HW 3 Elaboration ================================

2.
  a. First, Fsharp determines that fun f must be of type 'a. Next, FSharp looks
     at the match statement to determine what the resultant of the expression
     will be. FSharp finds that the return type of all arms of the match statement
     is an integer and determines that the type is int -> int.
  b. Fsharp first determines that x must be of type 'a. Next, Fsharp looks at the function
    declaration to determine that x must be of type 'a list to use the append operator.
    Finally, Fsharp determines that the return type is also of type 'a list, thus
    making the type of the function x: 'a list -> ('a list -> 'a list).
  c. First, FSharp determines that fun x must be of type 'a. Next, FSharp determines that 'a must
     be an int to satisfy the appending of 5 to x. Finally, FSharp determines that the function
     takes an input parameter of type int and returns an int list.
  d. f: (string -> string) -> int
  e. First, FSharp looks at the function declaration and determines that x must be of
     type 'a and y must be of type 'b. Next, FSharp looks at the function internals to
     determine that the returned value must be of type string as a concatenation of x and y
     is occurring with a string of a space value. Finally, FSharp determines that both
     x and y must be type string.
